<!DOCTYPE html>
<html lang="zh-CN">
<head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="UTF-8">

    

    

    <title>CRCMS</title>
    <meta name="author" content="simon">
    <meta name="keywords" content>
    <meta name="description" content="大道至简">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no">

    
    <link rel="alternate" href="/atom.xml" title="CRCMS" type="application/atom+xml">
    
    
    <link rel="icon" href="/images/favicon.png">
    

    <style type="text/css">
    @font-face {
        font-family: 'icomoon';
        src: url("/fonts/icomoon.eot?q628ml");
        src: url("/fonts/icomoon.eot?q628ml#iefix") format('embedded-opentype'),
             url("/fonts/icomoon.ttf?q628ml") format('truetype'),
             url("/fonts/icomoon.woff?q628ml") format('woff'),
             url("/fonts/icomoon.svg?q628ml#icomoon") format('svg');
        font-weight: normal;
        font-style: normal;
    }
    </style>
    <link rel="stylesheet" href="/css/style.css">

    <!--[if lt IE 9]>
    <style type="text/css">
    .nav-inner {top:0;}
    .author-meta {position:static;top:0;}
    .search-form {height:36px;}
    </style>
    <script type="text/javascript" src="https://unpkg.com/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
    <![endif]-->
</head>
<body>

    <main class="app">
        <header id="header" class="header clearfix">
    <div id="nav" class="nav">
    <div class="nav-mobile">
        <button id="open-panel" class="open-panel nav-mobile-item"><i class="icon-documents"></i></button>
        <h1 class="nav-mobile-title nav-mobile-item">CRCMS</h1>
        <button id="open-menus" class="open-panel nav-mobile-item"><i class="icon-library"></i></button>
    </div>

    <nav id="nav-inner" class="nav-inner">
        
            <a class="nav-item active" href="/">
                <span class="nav-text">首页</span>
            </a>
        
            <a class="nav-item" href="/tags">
                <span class="nav-text">标签</span>
            </a>
        
            <a class="nav-item" href="/archives">
                <span class="nav-text">归档</span>
            </a>
        
            <a class="nav-item" href="/about">
                <span class="nav-text">关于</span>
            </a>
        
            <a class="nav-item" href="/reward">
                <span class="nav-text">支持</span>
            </a>
        
    </nav>
</div>

    <aside id="aside" class="aside">
    <div id="aside-mask" class="aside-mask"></div>
    <div id="aside-inner" class="aside-inner">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit"><i class="icon-search-stroke"></i></button><input type="hidden" name="sitesearch" value="http://blog.crcms.cn"></form>

        
        

        
        <div class="author-meta">
            
            <div class="author-avatar">
                <a href="/">
                    <img src="/images/avatar.jpeg" title="Simon">
                </a>
            </div>
            
            <div class="author-name">Simon</div>
            <div class="author-work">Golang,PHP Developer &amp; Designer</div>
            <div class="author-location">
                <i class="icon-location vm"></i>
                <span class="vm">Hefei, China</span>
            </div>
            
            <div class="author-thread-wrap">
                <div class="author-threads clearfix">
                    
                        <a class="thread-item" href="https://github.com/crcms" target="_blank" rel="noopener">
                            <!-- Generated by IcoMoon.io -->
<svg viewbox="0 0 1024 1024" width="38" height="38" fill="currentColor">
<path d="M512 32.12c-265.004 0-479.88 220.23-479.88 492.090 0 217.446 137.536 401.684 328.202 466.81 23.994 4.498 32.778-10.712 32.778-23.78 0-11.782-0.428-42.632-0.642-83.764-133.466 29.778-161.744-65.984-161.744-65.984-21.852-56.772-53.344-71.982-53.344-71.982-43.49-30.636 3.214-29.992 3.214-29.992 48.202 3.428 73.482 50.772 73.482 50.772 42.846 75.196 112.258 53.558 139.68 40.918 4.284-31.706 16.71-53.558 30.42-65.77-106.474-12.426-218.516-54.63-218.516-243.152 0-53.772 18.638-97.69 49.274-131.966-4.928-12.426-21.424-62.556 4.714-130.252 0 0 40.276-13.282 131.966 50.344 38.348-10.926 79.266-16.282 120.184-16.496 40.704 0.214 81.836 5.57 120.184 16.496 91.692-63.626 131.752-50.344 131.752-50.344 26.136 67.698 9.64 117.828 4.714 130.252 30.636 34.492 49.274 78.408 49.274 131.966 0 188.952-112.258 230.514-219.16 242.724 17.138 15.21 32.564 45.202 32.564 91.048 0 65.77-0.642 118.898-0.642 134.966 0 13.068 8.57 28.492 32.992 23.566 191.094-64.912 328.418-249.152 328.418-466.382 0-271.86-214.874-492.090-479.88-492.090z"/>
</svg>

                        </a>
                    
                        <a class="thread-item" href="https://github.com/firmeve" target="_blank" rel="noopener">
                            <!-- Generated by IcoMoon.io -->
<svg viewbox="0 0 1024 1024" width="38" height="38" fill="currentColor">
<path d="M512 32.12c-265.004 0-479.88 220.23-479.88 492.090 0 217.446 137.536 401.684 328.202 466.81 23.994 4.498 32.778-10.712 32.778-23.78 0-11.782-0.428-42.632-0.642-83.764-133.466 29.778-161.744-65.984-161.744-65.984-21.852-56.772-53.344-71.982-53.344-71.982-43.49-30.636 3.214-29.992 3.214-29.992 48.202 3.428 73.482 50.772 73.482 50.772 42.846 75.196 112.258 53.558 139.68 40.918 4.284-31.706 16.71-53.558 30.42-65.77-106.474-12.426-218.516-54.63-218.516-243.152 0-53.772 18.638-97.69 49.274-131.966-4.928-12.426-21.424-62.556 4.714-130.252 0 0 40.276-13.282 131.966 50.344 38.348-10.926 79.266-16.282 120.184-16.496 40.704 0.214 81.836 5.57 120.184 16.496 91.692-63.626 131.752-50.344 131.752-50.344 26.136 67.698 9.64 117.828 4.714 130.252 30.636 34.492 49.274 78.408 49.274 131.966 0 188.952-112.258 230.514-219.16 242.724 17.138 15.21 32.564 45.202 32.564 91.048 0 65.77-0.642 118.898-0.642 134.966 0 13.068 8.57 28.492 32.992 23.566 191.094-64.912 328.418-249.152 328.418-466.382 0-271.86-214.874-492.090-479.88-492.090z"/>
</svg>

                        </a>
                    
                </div>
            </div>
            
        </div>
        
    </div>
</aside>

</header>

        <div id="content" class="content">
            <div id="wrapper" class="wrapper" style="max-width: 800px">
                
    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2020/06/11/linux-base-3/">夯实Linux基础 - 用户和组管理</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="http://blog.crcms.cn/index.html">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2020-06-11T10:34:52.000Z" itemprop="datePublished">2020-06-11</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/linux/">linux</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h2 id="用户管理命令"><a href="#用户管理命令" class="headerlink" title="用户管理命令"></a>用户管理命令</h2><p>添加用户</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">useradd [options] USERNAME</span><br></pre></td></tr></table></figure>

<p>常用选项：</p>
<p>​    -c 基本的注释信息<br>​    -d 指定创建的家目录<br>​    -m 创建时自动创建目录，通常配合<code>-k</code>选项使用<br>​    -k 会自动把<code>/etc/skel</code>中的基本<code>bash</code>配置文件拷贝到当前创建用户的家目录<br>​    -u 指定用户ID<br>​    -g 指定的基本组ID号（组必须存在）<br>​    -G 指定的附加组，格式如 <code>1,2</code> 或组名 `user,game<br>​    -r 创建系统用户<br>​    -s 指定运行的SHELL</p>
<blockquote>
<p>使用<code>-r</code>时系统会创建系统用户，系统用户的ID标识，如果未指定，是在<code>100-999</code>并且未被使用范围内，具体范围可参考<code>/etc/login.defs</code>中的<code>SYS_UID_MIN</code>和<code>SYS_UID_MAX</code></p>
</blockquote>
<p>修改用户</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">usermod [options] LOGIN</span><br></pre></td></tr></table></figure>

<p>常用选项：</p>
<p>​    -c 基本的注释信息<br>​    -d 指定创建的家目录<br>​    -m 移动已存在的用户家目录到指定位置<br>​    -u 指定用户ID<br>​    -g 指定的基本组ID号（组必须存在）<br>​    -G 指定的附加组，格式如 <code>1,2</code> 或组名 <code>user,game</code> ， <code>-a</code>选项表示在原附加组上进行追加<br>​    -s 指定运行的SHELL<br>​    -L 锁定该用户<br>​    -U 解锁该用户</p>
<p>删除用户</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">userdel [options] LOGIN</span><br></pre></td></tr></table></figure>

<p>常用选项：</p>
<p>​    -r 删除用户的家目录</p>
        
        <p class="article-more-link">
            <a href="/2020/06/11/linux-base-3/#more">
                <span class="vm">阅读更多</span>
                <i class="icon-arrow-double-right vm"></i>    
            </a>
        </p>
        
        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2020/06/09/linux-base-2/">夯实Linux基础 - 文件系统基础命令</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="http://blog.crcms.cn/index.html">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2020-06-09T17:34:52.000Z" itemprop="datePublished">2020-06-10</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/linux/">linux</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h2 id="目录及文件操作命令"><a href="#目录及文件操作命令" class="headerlink" title="目录及文件操作命令"></a>目录及文件操作命令</h2><p>进入指定目录</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> [directory]</span><br></pre></td></tr></table></figure>

<p><code>cd</code> 默认进入指定目录</p>
<p><code>cd ~</code>进入当前home目录</p>
<p><code>cd -</code> 返回上一层目录</p>
<p>创建目录</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir [OPTION]... DIRECTORY...</span><br></pre></td></tr></table></figure>

<p>常用选项：</p>
<p>​    -m 创建的权限码</p>
<p>​    -p 递归创建</p>
<p>​    -v 显示创建详情</p>
<p>创建文件或创建目录</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">install [OPTION]... SOURCE... DIRECTORY</span><br></pre></td></tr></table></figure>

<p>常用选项：</p>
<p>​    -d 创建目录</p>
<blockquote>
<p><code>install</code> 命令复制文件，会自动增加执行权限</p>
</blockquote>
<p>一个参数创建多个目录：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建 /tmp/foo/f1 /tmp/foo/f2</span></span><br><span class="line">mkdir -pv /tmp/foo/&#123;f1,f2&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建 /tmp/foo/z1/s1 /tmp/foo/z2</span></span><br><span class="line">mkdir -pv /tmp/foo/&#123;z1/s1,z2&#125;</span><br></pre></td></tr></table></figure>

<p>查看目录内容</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls [OPTION]... [FILE]...</span><br></pre></td></tr></table></figure>

<p>常用选项：</p>
<p>​    -a 显示隐藏文件</p>
<p>​    -r 倒序排列</p>
<p>   -R 递归显示所有</p>
<p>​    -l 使用表格式的列表格式展示</p>
<p>移动或重命名文件</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv [OPTION]... SOURCE... DIRECTORY</span><br></pre></td></tr></table></figure>

<p>创建一个空白文件或更改文件时间</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch [OPTION]... FILE...</span><br></pre></td></tr></table></figure>

<p>常用选项：</p>
<p>​    -c 不创建文件</p>
<p>​    -m 仅修改修改时间</p>
<p>​    -a 修改访问时间</p>
<p>​    </p>
<p>查看文件属性</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">stat</span> [OPTION]... FILE...</span><br></pre></td></tr></table></figure>

<p>查看文件的内容或类型</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file [OPTION...] [FILE...]</span><br></pre></td></tr></table></figure>
        
        <p class="article-more-link">
            <a href="/2020/06/09/linux-base-2/#more">
                <span class="vm">阅读更多</span>
                <i class="icon-arrow-double-right vm"></i>    
            </a>
        </p>
        
        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2020/06/09/linux-base-1/">夯实Linux基础 - 入门</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="http://blog.crcms.cn/index.html">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2020-06-09T17:34:33.000Z" itemprop="datePublished">2020-06-10</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/linux/">linux</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h2 id="文件目录结构"><a href="#文件目录结构" class="headerlink" title="文件目录结构"></a>文件目录结构</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">├── bin                                     可执行文件，用户命令，系统启动相关的</span><br><span class="line">├── boot                                    系统启动文件</span><br><span class="line">├── dev                                     设备文件，设备数据的访问入口(块设备,字符设备)</span><br><span class="line">├── etc                                     配置文件</span><br><span class="line">├── home</span><br><span class="line">├── lib                                     库文件</span><br><span class="line">├── lib64                                   库文件64位</span><br><span class="line">├── media                                   挂载点目录，通常用于挂载移动设备</span><br><span class="line">├── mnt                                     额外的临时文件系统，如第二块硬盘</span><br><span class="line">├── opt                                     可选目录，早期通常用于第三方安装程序的安装目录，现在基本安装在/usr/local中</span><br><span class="line">├── proc                                    伪文件系统，内核的映射文件</span><br><span class="line">├── root                                    root用户目录</span><br><span class="line">├── run                                     系统运行目录</span><br><span class="line">├── sbin                                    可执行文件，系统命令，系统启动相关的</span><br><span class="line">├── sys                                     伪文件系统 和硬件设备相关的属性映射文件</span><br><span class="line">├── tmp                                     系统临时文件</span><br><span class="line">├── usr                                     Unix操作系统软件资源所放置的目录(Unix Software Resource)</span><br><span class="line">│   ├── bin                                 主要是用于系统启动后提供的一系列用户命令</span><br><span class="line">│   ├── local                               第三方软件</span><br><span class="line">│   │   ├── bin</span><br><span class="line">│   │   ├── lib</span><br><span class="line">│   │   ├── share</span><br><span class="line">│   │   └── sbin</span><br><span class="line">│   ├── lib                                 不包含于系统核心库的库</span><br><span class="line">│   └── sbin                                主要是用于系统启动后提供的一系列系统命令</span><br><span class="line">└── var                                     可变目录</span><br></pre></td></tr></table></figure>
        
        <p class="article-more-link">
            <a href="/2020/06/09/linux-base-1/#more">
                <span class="vm">阅读更多</span>
                <i class="icon-arrow-double-right vm"></i>    
            </a>
        </p>
        
        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2019/12/27/http-tcp/">Http/TCP 基础协议</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="http://blog.crcms.cn/index.html">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2019-12-27T06:30:17.000Z" itemprop="datePublished">2019-12-27</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/Http/">Http</a>, <a class="article-tag-link" href="/tags/TCP/">TCP</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h2 id="请求头"><a href="#请求头" class="headerlink" title="请求头"></a>请求头</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">方法+空格+URI+空格+协议版本\r\n</span><br><span class="line">首部字段\r\n</span><br><span class="line">\r\n</span><br><span class="line">主体</span><br></pre></td></tr></table></figure>

<p>如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">post /api/v1/register http/1.1</span><br><span class="line">Host: firmeve.com</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Content-Type: application/json</span><br><span class="line"></span><br><span class="line">&#123;&quot;name&quot;:&quot;simon&quot;,&quot;mobile&quot;:&quot;&quot;&#125;</span><br></pre></td></tr></table></figure>

<h2 id="响应头"><a href="#响应头" class="headerlink" title="响应头"></a>响应头</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">协议版本+空格+状态码+状态描述\r\n</span><br><span class="line">首部字段\r\n</span><br><span class="line">\r\n</span><br><span class="line">主体</span><br></pre></td></tr></table></figure>
        
        <p class="article-more-link">
            <a href="/2019/12/27/http-tcp/#more">
                <span class="vm">阅读更多</span>
                <i class="icon-arrow-double-right vm"></i>    
            </a>
        </p>
        
        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2019/12/17/golang-rabbitmq-demo/">Golang RabbitMQ demo</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="http://blog.crcms.cn/index.html">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2019-12-17T06:30:17.000Z" itemprop="datePublished">2019-12-17</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/AMQP/">AMQP</a>, <a class="article-tag-link" href="/tags/RabbitMQ/">RabbitMQ</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h2 id="AMQP协议"><a href="#AMQP协议" class="headerlink" title="AMQP协议"></a>AMQP协议</h2><p>AMQP（Advanced Message Queuing Protocol，高级消息队列协议）是一个进程间传递异步消息的网络协议。</p>
<p>RabbitMQ 就是 amqp 协议的Erlang的实现。</p>
<p>AMQP的模型架构的主要角色，生产者、消费者、交换器、队列。</p>
<h2 id="生产者、消费者、服务节点"><a href="#生产者、消费者、服务节点" class="headerlink" title="生产者、消费者、服务节点"></a>生产者、消费者、服务节点</h2><ul>
<li>生产者(Producter) 消息投递方</li>
<li>消费者(Consumer) 消息接收方</li>
<li>服务节点(Broker) 消息的服务节点，基本上可以简单的把一个broker看成一台消息服务器
        
        <p class="article-more-link">
            <a href="/2019/12/17/golang-rabbitmq-demo/#more">
                <span class="vm">阅读更多</span>
                <i class="icon-arrow-double-right vm"></i>    
            </a>
        </p>
        
        
    </li></ul></section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2019/10/29/mysql8-gtic-replication/">Mysql8下GTID复制</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="http://blog.crcms.cn/index.html">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2019-10-29T06:39:31.000Z" itemprop="datePublished">2019-10-29</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/GTID复制/">GTID复制</a>, <a class="article-tag-link" href="/tags/mysql/">mysql</a>, <a class="article-tag-link" href="/tags/replication/">replication</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><p>之前介绍了通过<code>binlog Pos</code>来进行主从复制，基于复制点(pos)来进行复制，在迁移或因故障未能及时同步<br>等问题下必须重新定位复制点，非常麻烦，特别是对于多台mysql而言。而GTID就可以很好的解决这个问题。<br>GTID自动检测二进制日志的位置。</p>
<h2 id="什么是GTID"><a href="#什么是GTID" class="headerlink" title="什么是GTID?"></a>什么是GTID?</h2><p>全局事务标识符（Global Transaction Identifier, GTID ）是在程序中创建的唯一标识符，并与主库上提交的每个事务相关联。<br>此标识符是唯一的，不仅在其主库上，在给定的复制设置中的所有数据库上，它都是唯一的。<br>所有事务和所有GTID之间都是一对一的映射关系。<br>GTID用一对坐标表示，用冒号（：）分隔：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GTID = source_id:transaction_id</span><br></pre></td></tr></table></figure>

<p>source_id是主库的标识。通常，服务器的server_uuid选项就代表此标识。transaction_id 是一个序列号，由在该服务器上提交事务的顺序决定。</p>
<h2 id="主要步骤"><a href="#主要步骤" class="headerlink" title="主要步骤"></a>主要步骤</h2><ol>
<li>master 开启<code>binlog</code></li>
<li>创建复制用户</li>
<li>设置 master 以及 slave 惟一的<code>server_id</code>,<code>gtid_mode</code>,<code>enforce_gtid_consistency</code></li>
<li>在 slave 上执行<code>change master to MASTER_AUTO_POSITION=1</code></li>
<li>执行<code>start slave</code></li>
</ol>
<h2 id="完整示例"><a href="#完整示例" class="headerlink" title="完整示例"></a>完整示例</h2><p>开启3台mysql，分别命令为master,slave,slave2，初始配置如下：<br>其中slave2我们使用延时同步，主要是为了更好的灾备。</p>
<p>master:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">skip-host-cache</span><br><span class="line">skip-name-resolve</span><br><span class="line"></span><br><span class="line">[mysql]</span><br></pre></td></tr></table></figure>

<p>slave:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">skip-host-cache</span><br><span class="line">skip-name-resolve</span><br><span class="line"></span><br><span class="line">[mysql]</span><br></pre></td></tr></table></figure>

<p>slave2:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">skip-host-cache</span><br><span class="line">skip-name-resolve</span><br><span class="line"></span><br><span class="line">[mysql]</span><br></pre></td></tr></table></figure>

<p>运行Mysql</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -it -v /tmp/mysql/master/conf:/etc/mysql/conf.d -v /tmp/mysql/slave/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=root --name master mysql</span><br><span class="line">docker run -d -it -v /tmp/mysql/slave/conf:/etc/mysql/conf.d -v /tmp/mysql/master/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=root --name slave mysql</span><br><span class="line">docker run -d -it -v /tmp/mysql/slave2/conf:/etc/mysql/conf.d -v /tmp/mysql/slave2/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=root --name slave2 mysql</span><br><span class="line"><span class="comment"># 创建桥接网络</span></span><br><span class="line">docker network create mysql</span><br><span class="line">docker network connect --<span class="built_in">alias</span> master mysql master</span><br><span class="line">docker network connect --<span class="built_in">alias</span> slave mysql slave</span><br><span class="line">docker network connect --<span class="built_in">alias</span> slave2 mysql slave2</span><br></pre></td></tr></table></figure>

<p>docker ps查看保证mysql都已经启动，然后增加binlog和gtid的配置</p>
<p>master:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">log_bin=/var/lib/mysql/bin_logs/master</span><br><span class="line">server_id=100</span><br><span class="line">gtid_mode=on</span><br><span class="line">enforce_gtid_consistency=on</span><br></pre></td></tr></table></figure>

<p>slave:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">log_bin=/var/lib/mysql/bin_logs/slave</span><br><span class="line">server_id=101</span><br><span class="line">gtid_mode=on</span><br><span class="line">enforce_gtid_consistency=on</span><br></pre></td></tr></table></figure>

<p>slave2:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">log_bin=/var/lib/mysql/bin_logs/slave</span><br><span class="line">server_id=103</span><br><span class="line">gtid_mode=on</span><br><span class="line">enforce_gtid_consistency=on</span><br></pre></td></tr></table></figure>

<p>在master上增加复制帐户</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">create user &apos;binlog_user&apos;@&apos;%&apos; identified with mysql_native_password by &apos;binlog_password&apos;;</span><br><span class="line">grant replication slave on *.* to &apos;binlog_user&apos;@&apos;%&apos;;</span><br><span class="line">flush privileges;</span><br></pre></td></tr></table></figure>

<p>重启master和slave</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker restart master</span><br><span class="line">docker restart slave</span><br><span class="line">docker restart slave2</span><br></pre></td></tr></table></figure>

<p>在slave中增加<code>change master to</code> 并 <code>start slave</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">change master to master_host=<span class="string">'master'</span>,master_user=<span class="string">'binlog_user'</span>,master_password=<span class="string">'binlog_password'</span>,master_port=3306,master_auto_position=1;</span><br><span class="line">start slave;</span><br></pre></td></tr></table></figure>

<p>在slave中增加<code>change master to</code> 并 <code>start slave</code>并开启延时</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">change master to master_host=<span class="string">'master'</span>,master_user=<span class="string">'binlog_user'</span>,master_password=<span class="string">'binlog_password'</span>,master_port=3306,master_auto_position=1,master_delay=10;</span><br><span class="line">start slave;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里注意，master_delay=10表示开启了10秒延时</p>
</blockquote>
<h2 id="查看slave和master状态"><a href="#查看slave和master状态" class="headerlink" title="查看slave和master状态"></a>查看slave和master状态</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show master status\G;</span><br></pre></td></tr></table></figure>

<p><img src="/images/mysql8-gtic-replication/master_status.png" alt="binlog"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show slave status\G;</span><br></pre></td></tr></table></figure>

<p>可以看到slave的Slave_IO_State: Waiting for master to send event<br><img src="/images/mysql8-gtic-replication/slave_status.png" alt="binlog"></p>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>在主库中创建数据库并写入数据</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">create database tv default charset utf8mb4 collate utf8mb4_unicode_ci;</span><br><span class="line">create table t1 (</span><br><span class="line">  id int(10) unsigned primary key auto_increment,</span><br><span class="line">  content text default null</span><br><span class="line">);</span><br><span class="line">#写入数据</span><br><span class="line">use tv;</span><br><span class="line">insert into t1(content) values(&apos;1&apos;),(&apos;2&apos;),(&apos;3&apos;),(&apos;4&apos;);</span><br></pre></td></tr></table></figure>

<h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><p>登录slave和slave2分别查看可以看到，数据已经同步，其中slave2是延时同步，也已经生效。<br><img src="/images/mysql8-gtic-replication/slave1_demo.png" alt="binlog"><br><img src="/images/mysql8-gtic-replication/slave1_demo.png" alt="binlog"></p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>master正常写入数据<br>重启slave和slave2随后也是可以正常同步的</p>
<blockquote>
<p>如果希望从库重启后不进行自动同步，需要在配置中增加<code>skip_slave_start</code><br>还要注意的是，这里的示例是全部新库，如果原来是使用pos位置同步这里并不完全适用<br>需要先设置master为read only，等待所有从库全部同步完成才可以进行切换</p>
</blockquote>

        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2019/10/14/mysql8-binlog-replication/">Mysql8下主从复制、主主复制、多源复制</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="http://blog.crcms.cn/index.html">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2019-10-14T23:27:31.000Z" itemprop="datePublished">2019-10-15</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/mysql/">mysql</a>, <a class="article-tag-link" href="/tags/replication/">replication</a>, <a class="article-tag-link" href="/tags/主主复制/">主主复制</a>, <a class="article-tag-link" href="/tags/主从复制/">主从复制</a>, <a class="article-tag-link" href="/tags/多源复制/">多源复制</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><p>复制的原理如下：在主库上执行的所有<code>DDL</code>和<code>DML</code>语句都会被记录到二进制日志中，也就是<code>binlog</code>。<br>这些日志由连接到它的从库提取。它们只是被复制到从库，并被保存为中继日志。这个过程由<code>IO线程</code>的线程负责。还有一个<code>SQL线程</code>，它按顺序执行中继日志中的语句。</p>
<h2 id="主要步骤"><a href="#主要步骤" class="headerlink" title="主要步骤"></a>主要步骤</h2><p>不管是主主，还是多源，其基础配置都和主从差不多，所以就列出主从的基本步骤：</p>
<ol>
<li>master 开启<code>binlog</code></li>
<li>创建复制用户</li>
<li>设置 master 以及 slave 惟一的<code>server_id</code></li>
<li>在 slave 上执行<code>change master to</code></li>
<li>执行<code>start slave</code></li>
</ol>
<h2 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h2><h3 id="增加binlog配置"><a href="#增加binlog配置" class="headerlink" title="增加binlog配置"></a>增加binlog配置</h3><p>如果不想要自定义配置，先看下系统是否开启了binlog即可</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show variables like <span class="string">'%log_bin%'</span></span><br></pre></td></tr></table></figure>

<p><img src="/images/mysql8-replication/log_bin.png" alt="binlog"></p>
<p>增加或修改<code>binlog</code>配置，一同增加<code>server_id</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">log-bin=/var/lib/mysql/bin_logs/master</span><br><span class="line">expire_logs_days=7</span><br><span class="line">max_binlog_size=1GB</span><br><span class="line"></span><br><span class="line">server_id=1</span><br></pre></td></tr></table></figure>

<blockquote>
<p>其它更多<code>binlog</code>配置请参考官方文档</p>
</blockquote>
<p>查看<code>binlog</code>其它配置</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW VARIABLES LIKE <span class="string">'%binlog%'</span>;</span><br></pre></td></tr></table></figure>

<p><img src="/images/mysql8-replication/bin_log.png" alt="binlog"></p>
<p>查看所有<code>binlog</code>及大小</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show master logs(或者 show binary logs)</span><br></pre></td></tr></table></figure>

<p><img src="/images/mysql8-replication/logs.png" alt="binlog"></p>
<p>查看当前最新<code>binlog</code>位置</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show master status;</span><br></pre></td></tr></table></figure>

<p><img src="/images/mysql8-replication/master_status.png" alt="binlog"></p>
<p>查看<code>binlog</code>所有位置及其它信息</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show binlog events;</span><br></pre></td></tr></table></figure>

<p><img src="/images/mysql8-replication/binlog_events.png" alt="binlog"></p>
<p>移至下一个日志（开启新日志）</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flush logs;</span><br></pre></td></tr></table></figure>

<p><img src="/images/mysql8-replication/flush_logs.png" alt="binlog"></p>
<h3 id="创建复制用户"><a href="#创建复制用户" class="headerlink" title="创建复制用户"></a>创建复制用户</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">create user <span class="string">'binlog_user'</span>@<span class="string">'%'</span> identified with mysql_native_password by <span class="string">'binlog_password'</span>;</span><br><span class="line">grant replication slave on *.* to <span class="string">'binlog_user'</span>@<span class="string">'%'</span>;</span><br><span class="line">flush privileges;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>需要的权限以及连接的服务器请自行修改</p>
</blockquote>
<h3 id="修改slave配置，增加server-id"><a href="#修改slave配置，增加server-id" class="headerlink" title="修改slave配置，增加server_id"></a>修改slave配置，增加<code>server_id</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">server_id=100</span><br></pre></td></tr></table></figure>

<h3 id="在slave中执行change-master-to"><a href="#在slave中执行change-master-to" class="headerlink" title="在slave中执行change master to"></a>在slave中执行<code>change master to</code></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">change master to master_host=<span class="string">'172.22.0.2'</span>,master_user=<span class="string">'binlog_user'</span>,master_password=<span class="string">'binlog_password'</span>,master_log_file=<span class="string">'master.000013'</span>,master_log_pos=155</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果配置增加未修改的话，请重启master和slave</p>
</blockquote>
<h3 id="开启复制"><a href="#开启复制" class="headerlink" title="开启复制"></a>开启复制</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">start slave</span><br></pre></td></tr></table></figure>

<h2 id="主主复制"><a href="#主主复制" class="headerlink" title="主主复制"></a>主主复制</h2><p><img src="/images/mysql8-replication/master_master.png" alt="binlog"><br>所谓主主复制，其实就是一台mysql既是主又是从，两台互为复制<br>需要新建一台mysql和从库开启方式一致，原主服务器再加上</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CHANGE MASTER TO MASTER HOST, MASTER USER,MASTER PASSWORD,MASTER LOG FILE,MASTER LOG POS</span><br><span class="line">start slave</span><br></pre></td></tr></table></figure>

<h2 id="多源复制"><a href="#多源复制" class="headerlink" title="多源复制"></a>多源复制</h2><p><img src="/images/mysql8-replication/master_master_slave.png" alt="binlog"><br>多游、复制可用于将多台服务器备份到单台服务器，合并表分片，以及将多台服务器中的数据整合到单台服务器。多源复制在应用事务时不会执行任何冲突检测或解析，并且如果需要的话，这些任务将留给应用程序来处理。在多源复制拓扑中，从库为每个主库创建一个复制通道，以便从中接收事务。</p>
<p>在slave上修改配置文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">master_info_repository=TABLE</span><br><span class="line">relay_log_info_repository=TABLE</span><br></pre></td></tr></table></figure>

<p>如果此时从库还在同步，也需要修改</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">stop slave; </span><br><span class="line">SET GLOBAL master_info_repository=&apos;TABLE&apos;;</span><br><span class="line">SET GLOBAL relay_log_info_repository=&apos;TABLE&apos;;</span><br></pre></td></tr></table></figure>

<p>重启slave即可</p>
<blockquote>
<p>注意：多源复制下，多主对一从，需要注意复制数据冲突问题</p>
</blockquote>

        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2019/09/29/go-ioc/">Golang Ioc容器</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="http://blog.crcms.cn/index.html">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2019-09-29T09:45:34.000Z" itemprop="datePublished">2019-09-29</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/golang/">golang</a>, <a class="article-tag-link" href="/tags/ioc/">ioc</a>, <a class="article-tag-link" href="/tags/reflect/">reflect</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>用惯了<code>Laravel</code>的<code>Ioc</code>，对象获取变得那么自然，初用<code>Go</code>，各<code>struct</code>,<code>func</code>都要自己解析<br>一堆<code>NewFunc</code>，索性自己搞了个<code>ioc</code><br><a href="https://github.com/firmeve/firmeve" target="_blank" rel="noopener">参见Github(https://github.com/firmeve/firmeve)</a></p>
<h2 id="对象绑定"><a href="#对象绑定" class="headerlink" title="对象绑定"></a>对象绑定</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f := NewFirmeve()</span><br></pre></td></tr></table></figure>

<h3 id="标量绑定"><a href="#标量绑定" class="headerlink" title="标量绑定"></a>标量绑定</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f.Bind(<span class="string">`bool`</span>, <span class="literal">false</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f.Bind(<span class="string">`string`</span>, <span class="string">"string"</span>)</span><br></pre></td></tr></table></figure>

<h3 id="Struct-绑定"><a href="#Struct-绑定" class="headerlink" title="Struct 绑定"></a><code>Struct</code> 绑定</h3><p>假设我们有如下<code>struct</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Foo <span class="keyword">struct</span> &#123;</span><br><span class="line">    Bar <span class="keyword">string</span>	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewFoo</span><span class="params">(bar <span class="keyword">string</span>)</span> <span class="title">Foo</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Foo&#123;Bar:bar&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们将<code>foo</code>绑定进我们的容器中</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f.Bind(<span class="string">`foo`</span>,NewFoo(<span class="string">"abc"</span>))</span><br></pre></td></tr></table></figure>

<h3 id="Prt-绑定"><a href="#Prt-绑定" class="headerlink" title="Prt 绑定"></a><code>Prt</code> 绑定</h3><p>绑定<code>prt</code>的<code>struct</code>类型是我们最常用的一种方式，请看下面的示例</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Baz <span class="keyword">struct</span> &#123;</span><br><span class="line">    Baz <span class="keyword">string</span>	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewBaz</span><span class="params">()</span> *<span class="title">Baz</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;Baz&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f.Bind(<span class="string">`baz`</span>, NewBaz())</span><br></pre></td></tr></table></figure>

<h3 id="函数绑定"><a href="#函数绑定" class="headerlink" title="函数绑定"></a>函数绑定</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewFoo</span><span class="params">()</span> <span class="title">Foo</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> Foo&#123;Bar:<span class="string">"default string"</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f.Bind(<span class="string">`foo`</span>, NewFoo)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>使用<code>Firmeve</code>在绑定的时候暂时不支持参数注入<br>注意：如果是非函数类型绑定，则会默认为单实例类型</p>
</blockquote>
<h3 id="已绑定值覆盖"><a href="#已绑定值覆盖" class="headerlink" title="已绑定值覆盖"></a>已绑定值覆盖</h3><p>我们通过<code>WithBindCover(true)</code>方法可以轻松设定覆盖参数</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">f.Bind(<span class="string">`bool`</span>, <span class="literal">false</span>)</span><br><span class="line">fmt.Printf(<span class="string">"%t"</span>,f.Get(<span class="string">`bool`</span>))</span><br><span class="line">f.Bind(<span class="string">`bool`</span>, <span class="literal">true</span>, WithBindCover(<span class="literal">true</span>))</span><br><span class="line">fmt.Printf(<span class="string">"%t"</span>,f.Get(<span class="string">`bool`</span>))</span><br></pre></td></tr></table></figure>

<h2 id="对象获取"><a href="#对象获取" class="headerlink" title="对象获取"></a>对象获取</h2><h3 id="验证对象是否存在"><a href="#验证对象是否存在" class="headerlink" title="验证对象是否存在"></a>验证对象是否存在</h3><p>在不确定容器中是否包含此对象时，请使用<code>Has</code>方法进行判断</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f.Has(<span class="string">`foo`</span>)</span><br></pre></td></tr></table></figure>

<h3 id="对象获取-1"><a href="#对象获取-1" class="headerlink" title="对象获取"></a>对象获取</h3><p>直接获取容器中的值</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f.Get(<span class="string">`foo`</span>)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：如果指的定的<code>key</code>不存在，则会抛出<code>panic</code>错误</p>
</blockquote>
<h3 id="新对象获取"><a href="#新对象获取" class="headerlink" title="新对象获取"></a>新对象获取</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewFoo</span><span class="params">()</span> <span class="title">Foo</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> Foo&#123;Bar:<span class="string">"default string"</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f.Bind(<span class="string">`foo`</span>, NewFoo)</span><br><span class="line">fmt.Printf(<span class="string">"%p\n"</span>,f.Get(<span class="string">"foo"</span>))</span><br><span class="line">fmt.Printf(<span class="string">"%p\n"</span>,f.Get(<span class="string">"foo"</span>))</span><br><span class="line">fmt.Printf(<span class="string">"%p\n"</span>,f.Get(<span class="string">"foo"</span>))</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在<code>Firmeve</code>中，如果需要每次重新得到一个新的结构体对象<br>必须绑定一个函数值，否则得到的将是一个单实例</p>
</blockquote>
<h3 id="单例获取"><a href="#单例获取" class="headerlink" title="单例获取"></a>单例获取</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewFoo</span><span class="params">()</span> <span class="title">Foo</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> Foo&#123;Bar:<span class="string">"default string"</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f.Bind(<span class="string">`foo`</span>, NewFoo())</span><br><span class="line">fmt.Printf(<span class="string">"%p\n"</span>,f.Get(<span class="string">"foo"</span>))</span><br><span class="line">fmt.Printf(<span class="string">"%p\n"</span>,f.Get(<span class="string">"foo"</span>))</span><br><span class="line">fmt.Printf(<span class="string">"%p\n"</span>,f.Get(<span class="string">"foo"</span>))</span><br></pre></td></tr></table></figure>

<h2 id="参数解析"><a href="#参数解析" class="headerlink" title="参数解析"></a>参数解析</h2><h3 id="函数自动解析"><a href="#函数自动解析" class="headerlink" title="函数自动解析"></a>函数自动解析</h3><p>让我们来看一个简单的示例</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> PersonName <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewPersonName</span><span class="params">()</span> <span class="title">PersonName</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> PersonName&#123;Name: <span class="string">"Firmeve"</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> PersonAge <span class="keyword">struct</span> &#123;</span><br><span class="line">	Age <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PersonAge</span><span class="params">()</span> *<span class="title">PersonAge</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;PersonAge&#123;Age: <span class="number">1</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">	name PersonName</span><br><span class="line">	age *PersonAge</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewPerson</span><span class="params">(name PersonName,age *PersonAge)</span> *<span class="title">NewPerson</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> NewPerson&#123;</span><br><span class="line">    	name: name</span><br><span class="line">    	age: age</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f.Bind(<span class="string">"PersonName"</span>, NewPersonName)</span><br><span class="line">f.Bind(<span class="string">"PersonAge"</span>, PersonAge)</span><br><span class="line">fmt.Printf(<span class="string">"%#v"</span>, f.Resolve(NewPerson))</span><br></pre></td></tr></table></figure>

<h3 id="结构体tag自动解析"><a href="#结构体tag自动解析" class="headerlink" title="结构体tag自动解析"></a>结构体tag自动解析</h3><p>现在，让我们修改下上面的<code>Person</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name PersonName <span class="string">`inject:"PersonName"`</span></span><br><span class="line">	Age *PersonAge <span class="string">`inject:"PersonAge"`</span></span><br><span class="line">	age1 *PersonAge <span class="string">`inject:"PersonAge"`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后我们使用<code>new</code>函数直接创建一个新的结构体指针</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fmt.Printf(<span class="string">"%#v"</span>, <span class="built_in">new</span>(NewPerson))</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：此时 <code>Person</code>中的<code>Name</code>字段并不是指针类型，而<code>age1</code>不符合<code>struct</code>的<code>tag</code>规范，所以<code>Firmeve</code>都会自动忽略。</p>
</blockquote>

        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2019/09/19/redis-basic-command/">Redis基础数据类型和常用操作命令</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="http://blog.crcms.cn/index.html">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2019-09-19T22:59:14.000Z" itemprop="datePublished">2019-09-20</time>
</a>

            

        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><p>经常用的都是通过代码包装好的<code>redis</code>调用程式，时间有些常用命令又模糊了，故拿出来记录下。</p>
<h2 id="基础数据类型"><a href="#基础数据类型" class="headerlink" title="基础数据类型"></a>基础数据类型</h2><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><h4 id="Add-Set"><a href="#Add-Set" class="headerlink" title="Add|Set"></a>Add|Set</h4><ul>
<li><code>SET key value [EX seconds|PX milliseconds] [NX|XX]</code> NX:相当于SETNX值不存在时增加，XX值存在覆盖</li>
<li><code>MSET key value key value ...</code> 一次设置多个值</li>
<li><code>SETNX key value</code> 原子性操作，当key不存在设置成功返回1，否则返回0</li>
<li><code>STRLEN key</code> 返回key的长度，不存在返回0，非string类型返回错误</li>
<li><code>APPEND key value</code> 在key的末尾追加字符串，返回字符串长度，原来的key不存在，则会增加（相当于SET）</li>
<li><code>SETRANGE key offset value</code> 替换字符串，从offset下标开始，替换strlen(value)位字符串</li>
</ul>
<h4 id="Get"><a href="#Get" class="headerlink" title="Get"></a>Get</h4><ul>
<li><code>EXISTS key ...</code> 判断key是否存在，返回存在key的个数，单个key不存在返回0</li>
<li><code>GET key</code> 获取key值</li>
<li><code>MGET key ...</code> 获取多个key的值</li>
</ul>
<h4 id="Delete"><a href="#Delete" class="headerlink" title="Delete"></a>Delete</h4><ul>
<li><code>DEL key ...</code> 删除指定key，成功返回删除个数</li>
</ul>
<blockquote>
<p><code>string</code>类型在redis中有三种存储方式</p>
<ul>
<li>int 64位有符号位整数</li>
<li>embstr 长度小于44个字节的字符串</li>
<li>raw 长度大于44个字节的字符串<br>其中raw效率相对最差，可以通过 <code>OBJECT ENCODING key</code>的命令来查看string的存储类型</li>
</ul>
</blockquote>
<h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><h4 id="Add-Set-1"><a href="#Add-Set-1" class="headerlink" title="Add|Set"></a>Add|Set</h4><ul>
<li><code>LPUSH key value ...</code> 左侧写入返回总列表个数</li>
<li><code>RPUSH key value ...</code> 右侧写入返回总列表个数</li>
<li><code>LINSERT key [BEFORE|AFTER] item value</code> 从左侧开始，指定元素(item)前或后插入新元素，返回总列表个数</li>
<li><code>LSET key index</code> 覆盖或增加指定索引的值，返回OK，超过最大list范围则会报错</li>
</ul>
<h4 id="Get-1"><a href="#Get-1" class="headerlink" title="Get"></a>Get</h4><ul>
<li><code>LRANGE key start stop</code> 获取指定范围的list, <code>lrange key 0 -1</code> 标识获取整个list</li>
<li><code>LINDEX key index</code> 获取指定索引处的元素，不存在返回nil</li>
<li><code>LLEN key</code> 获取列表长度</li>
</ul>
<h4 id="Delete-1"><a href="#Delete-1" class="headerlink" title="Delete"></a>Delete</h4><ul>
<li><code>LPOP key</code> 左侧弹出，返回总列表个数，当list不存在时返回nil</li>
<li><code>RPOP key</code> 右侧弹出，返回总列表个数，当list不存在时返回nil</li>
<li><code>LTRIM key start stop</code> 删除指定区间外的元素，返回OK</li>
<li><code>BLPOP key</code> LPOP阻塞式方法</li>
<li><code>BRPOP key</code> RPOP阻塞式方法</li>
</ul>
<h3 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h3><p>类似于<code>Go</code>中的<code>map</code>或<code>PHP</code>中的键值数组，用于存储字段的映射关系</p>
<h4 id="Add-Set-2"><a href="#Add-Set-2" class="headerlink" title="Add|Set"></a>Add|Set</h4><ul>
<li><code>HMSET key field value ...</code> 成功返回 <code>OK</code></li>
<li><code>HSET key field value ...</code> 增加field时返回新增field值的个数，覆盖时返回0(覆盖成功也是0)</li>
<li><code>HSETNX key field value</code> 当field不存在时增加成功返回1，如果field存则返回0,不可同时进行多个field操作</li>
</ul>
<h4 id="Get-2"><a href="#Get-2" class="headerlink" title="Get"></a>Get</h4><ul>
<li><code>HKEYS key</code> 返回当前hash中所有的field</li>
<li><code>HEXISTS key field</code> 判断当前key中是否存在field，存在返回1，否则返回0</li>
<li><code>HGETALL key</code> 返回当前Key的所有值，当HASH巨大的时候不适合使用此函数</li>
<li><code>HMGET key field ...</code> 返回当前key指定的field值</li>
<li><code>HSCAN key cursor [MATCH field] [COUNT number]</code> 通过指针移动来获取MATCH匹配的值，COUNT代表的是返回的元素个数，但即使设置了count也并不一定代表就返回count个元素，因此不可作为分页式数据</li>
<li><code>HLEN key</code> 获取Hash长度</li>
</ul>
<h4 id="Delete-2"><a href="#Delete-2" class="headerlink" title="Delete"></a>Delete</h4><ul>
<li><code>HDEL key field ...</code> 删除一个或多个field，当key全部删除后，key会被自动清除</li>
</ul>
<h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><h4 id="Add-Set-3"><a href="#Add-Set-3" class="headerlink" title="Add|Set"></a>Add|Set</h4><ul>
<li><code>SADD key member ...</code> 添加集合元素，返回添加的的元素数量</li>
</ul>
<h4 id="Get-3"><a href="#Get-3" class="headerlink" title="Get"></a>Get</h4><ul>
<li><code>SISMEMBER key member</code> 判断是否存在于集合，0表示不存在1存在</li>
<li><code>SMEMBERS key</code> 返回集合所有元素</li>
<li><code>SSCAN key cursor [MATCH member] [COUNT number]</code> 通过指针移动来获取MATCH匹配的值，COUNT代表的是返回的元素个数，但即使设置了count也并不一定代表就返回count个元素，因此不可作为分页式数据</li>
<li><code>SRANDMEMBER key count</code> 随机返回指定count元素</li>
<li><code>SUNION key key ...</code> 集合并集，返回合并后的值</li>
<li><code>SUNIONSTORE storeKey key key ...</code> 并集，并存储至storeKey中，索引相同则覆盖，返回合并个数</li>
<li><code>SINTER</code> 集合交集，返回合交集值</li>
<li><code>SINTERSTORE storeKey key key ...</code> 交集，并存储至storeKey中</li>
<li><code>SDIFF</code> 集合差集，返回合差集值</li>
<li><code>SDIFFSTORE diffKey key key ...</code> 差集，并存储至diffKey中</li>
<li><code>SCARD key</code> 获取集合元素数量</li>
</ul>
<h4 id="Delete-3"><a href="#Delete-3" class="headerlink" title="Delete"></a>Delete</h4><ul>
<li><code>DEL key</code> 删除集合</li>
</ul>

        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2019/08/27/go-lock/">Golang 锁的简单使用</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="http://blog.crcms.cn/index.html">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2019-08-27T22:01:34.000Z" itemprop="datePublished">2019-08-28</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/golang/">golang</a>, <a class="article-tag-link" href="/tags/lock/">lock</a>, <a class="article-tag-link" href="/tags/sync-mutex/">sync.mutex</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><p>Golang中的锁机制主要包含互斥锁和读写锁</p>
<h2 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h2><p>互斥锁是传统并发程序对共享资源进行控制访问的主要手段。在<code>Go</code>中主要使用<br><code>sync.Mutex</code>的结构体表示。</p>
<p>一个简单的示例：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mutex</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	<span class="keyword">var</span> mu sync.Mutex</span><br><span class="line">	mu.Lock()</span><br><span class="line">	fmt.Println(<span class="string">"locked"</span>)</span><br><span class="line">	mu.Unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或者也可以使用<code>defer</code>来实现，这在整个函数流程中全部要加锁时特别有用，还有一个好处就是可以防止忘记<code>Unlock</code></p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mutex</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	<span class="keyword">var</span> mu sync.Mutex</span><br><span class="line">	mu.Lock()</span><br><span class="line">	<span class="keyword">defer</span> mu.Unlock()</span><br><span class="line">	fmt.Println(<span class="string">"locked"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>互斥锁是开箱即用的，只需要申明<code>sync.Mutex</code>即可直接使用</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mu sync.Mutex</span><br></pre></td></tr></table></figure>

<p>互斥锁应该是<code>成对出现</code>，在同步语句不可以再对<code>锁加锁</code>，看下面的示例：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mutex</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	<span class="keyword">var</span> mu sync.Mutex</span><br><span class="line">	mu.Lock()</span><br><span class="line">	fmt.Println(<span class="string">"parent locked"</span>)</span><br><span class="line">	mu.Lock()</span><br><span class="line">	fmt.Println(<span class="string">"sub locked"</span>)</span><br><span class="line">	mu.Unlock()</span><br><span class="line">	mu.Unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时则会出现<code>fatal error: all goroutines are asleep - deadlock!</code>错误</p>
<p>同样，如果多次对一个锁解锁，则会出现<code>fatal error: sync: unlock of unlocked mutex</code>错误</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mutex</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	<span class="keyword">var</span> mu sync.Mutex</span><br><span class="line">	mu.Lock()</span><br><span class="line">	fmt.Println(<span class="string">"locked"</span>)</span><br><span class="line">	mu.Unlock()</span><br><span class="line">	mu.Unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么在<code>goroutine</code>中是否对外部锁加锁呢？</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mutex</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	<span class="keyword">var</span> mu sync.Mutex</span><br><span class="line">	fmt.Println(<span class="string">"parent lock start"</span>)</span><br><span class="line">	mu.Lock()</span><br><span class="line">	fmt.Println(<span class="string">"parent locked"</span>)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt;= <span class="number">2</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">            fmt.Printf(<span class="string">"sub(%d) lock start\n"</span>, i)</span><br><span class="line">            mu.Lock()</span><br><span class="line">            fmt.Printf(<span class="string">"sub(%d) locked\n"</span>, i)</span><br><span class="line">            time.Sleep(time.Microsecond * <span class="number">30</span>)</span><br><span class="line">            mu.Unlock()</span><br><span class="line">            fmt.Printf(<span class="string">"sub(%d) unlock\n"</span>, i)</span><br><span class="line">        &#125;(i)</span><br><span class="line">    &#125;</span><br><span class="line">	time.Sleep(time.Second * <span class="number">2</span>)</span><br><span class="line">	mu.Unlock()</span><br><span class="line">	fmt.Println(<span class="string">"parent unlock"</span>)</span><br><span class="line">	time.Sleep(time.Second * <span class="number">2</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先看上面的函数执行结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">parent lock start</span><br><span class="line">parent locked</span><br><span class="line">sub(0) lock start</span><br><span class="line">sub(2) lock start</span><br><span class="line">sub(1) lock start</span><br><span class="line">parent unlock // 必须等到父级先解锁，后面则会阻塞</span><br><span class="line">sub(0) locked // 解锁后子goroutine才能执行锁定</span><br><span class="line">sub(0) unlock</span><br><span class="line">sub(2) locked</span><br><span class="line">sub(2) unlock</span><br><span class="line">sub(1) locked</span><br><span class="line">sub(1) unlock</span><br></pre></td></tr></table></figure>

<p>为了方便调试，使用了<code>time.Sleep()</code>来延迟保证<code>goroutine</code>的执行<br>从结果中可以看出，当所有的<code>goroutine</code>遇到<code>Lock</code>时都会阻塞，而当<code>main</code>函数中的<code>Unlock</code>执行后，会有一个优先（无序）的<code>goroutine</code>来占得锁，其它的则再次进入阻塞状态。</p>
<p><strong>总结：</strong></p>
<ul>
<li>互斥锁必须成对出现</li>
<li>同级别互斥锁不能嵌套使用</li>
<li>父级中如果存在锁，当在<code>goroutine</code>中执行重复锁定操作时<code>goroutine</code>将被阻塞，直到原互斥锁解锁，多个<code>goroutine</code>将会争抢当前锁资源，其它继续阻塞。</li>
</ul>
<h2 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h2><p>读写锁和互斥锁不同之处在于，可以分别针对读操作和写操作进行分别锁定，这样对于性能有一定的提升。<br>读写锁，对于多个写操作，以及写操作和读操作之前都是互斥的这一点基本等同于互斥锁。<br>但是对于同时多个读操作之前却非互斥关系，这也是相读写锁性能高于互斥锁的主要原因。</p>
<p>读写锁也是开箱即用型的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var rwm = sync.RWMutex</span><br></pre></td></tr></table></figure>

<p>读写锁分为写锁和读锁：</p>
<ul>
<li><p>写锁定和写解锁</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rwm.Lock()</span><br><span class="line">rwm.Unlock()</span><br></pre></td></tr></table></figure>
</li>
<li><p>读锁定和读解锁</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rwm.RLock()</span><br><span class="line">rwm.RUnlock()</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>读写锁的读锁和写锁不能交叉相互解锁，否则会发生<code>panic</code>，如：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">rwMutex</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	<span class="keyword">var</span> rwm sync.RWMutex</span><br><span class="line"></span><br><span class="line">	rwm.Lock()</span><br><span class="line">	fmt.Println(<span class="string">"locked"</span>)</span><br><span class="line">	rwm.RUnlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>fatal error: sync: RUnlock of unlocked RWMutex</code></p>
<p>对于读写锁，同一资源可以同时有多个读锁定，如：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">rwMutex</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	<span class="keyword">var</span> rwm sync.RWMutex</span><br><span class="line"></span><br><span class="line">	rwm.RLock()</span><br><span class="line">	rwm.RLock()</span><br><span class="line">	rwm.RLock()</span><br><span class="line">	fmt.Println(<span class="string">"locked"</span>)</span><br><span class="line">	rwm.RUnlock()</span><br><span class="line">	rwm.RUnlock()</span><br><span class="line">	rwm.RUnlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但对于写锁定只能有一个（和互斥锁相同），同时使用多个会产生<code>deadlock</code>的<code>panic</code>，如：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">rwMutex</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	<span class="keyword">var</span> rwm sync.RWMutex</span><br><span class="line"></span><br><span class="line">	rwm.Lock()</span><br><span class="line">	rwm.Lock()</span><br><span class="line">	rwm.Lock()</span><br><span class="line">	fmt.Println(<span class="string">"locked"</span>)</span><br><span class="line">	rwm.Unlock()</span><br><span class="line">	rwm.Unlock()</span><br><span class="line">	rwm.Unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>在<code>goroutine</code>中，写解锁会试图唤醒所有想要进行读锁定而被阻塞的<code>goroutine</code>。</strong></p>
<p><strong>而读解锁会在已无任何读锁定的情况下，试图唤醒一个想进行写锁定而被阻塞的<code>goroutine</code>。</strong></p>
<p>下面看一个完整示例：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">rwMutex</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> rwm sync.RWMutex</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt;= <span class="number">2</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">            fmt.Printf(<span class="string">"go(%d) start lock\n"</span>, i)</span><br><span class="line">            rwm.RLock()</span><br><span class="line">            fmt.Printf(<span class="string">"go(%d) locked\n"</span>, i)</span><br><span class="line">            time.Sleep(time.Second * <span class="number">2</span>)</span><br><span class="line">            rwm.RUnlock()</span><br><span class="line">            fmt.Printf(<span class="string">"go(%d) unlock\n"</span>, i)</span><br><span class="line">        &#125;(i)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 先sleep一小会，保证for的goroutine都会执行</span></span><br><span class="line">    time.Sleep(time.Microsecond * <span class="number">100</span>)</span><br><span class="line">    fmt.Println(<span class="string">"main start lock"</span>)</span><br><span class="line">    <span class="comment">// 当子进程都执行时，且子进程所有的资源都已经Unlock了</span></span><br><span class="line">    <span class="comment">// 父进程才会执行</span></span><br><span class="line">    rwm.Lock()</span><br><span class="line">    fmt.Println(<span class="string">"main locked"</span>)</span><br><span class="line">    time.Sleep(time.Second)</span><br><span class="line">    rwm.Unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">go(0) start lock</span><br><span class="line">go(0) locked</span><br><span class="line">go(1) start lock</span><br><span class="line">go(1) locked</span><br><span class="line">go(2) start lock</span><br><span class="line">go(2) locked</span><br><span class="line">main start lock</span><br><span class="line">go(2) unlock</span><br><span class="line">go(0) unlock</span><br><span class="line">go(1) unlock</span><br><span class="line">main locked</span><br></pre></td></tr></table></figure>

<p>反复执行上述示例中，可以看到，写锁定会阻塞<code>goroutine</code><br>最开始先在<code>main</code>中<code>sleep 100ms</code> ，保证子的<code>goroutine</code>会全部执行，而每个子<code>goroutine</code>会<code>sleep 2s</code>。<br>此时会阻塞整个<code>main</code>进程，当所有子<code>goroutine</code>执行结束，读解锁后，main的写锁定才会执行。</p>
<p>再看一个读锁定示例：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">rwMutex5</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> rwm sync.RWMutex</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt;= <span class="number">2</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">			fmt.Printf(<span class="string">"go(%d) start lock\n"</span>, i)</span><br><span class="line">			rwm.RLock()</span><br><span class="line">			fmt.Printf(<span class="string">"go(%d) locked\n"</span>, i)</span><br><span class="line">			time.Sleep(time.Second * <span class="number">2</span>)</span><br><span class="line">			rwm.RUnlock()</span><br><span class="line">			fmt.Printf(<span class="string">"go(%d) unlock\n"</span>, i)</span><br><span class="line">		&#125;(i)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">"main start lock"</span>)</span><br><span class="line">	rwm.RLock()</span><br><span class="line">	fmt.Println(<span class="string">"main locked"</span>)</span><br><span class="line">	time.Sleep(time.Second * <span class="number">10</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">main start lock</span><br><span class="line">main locked</span><br><span class="line">go(1) start lock</span><br><span class="line">go(1) locked</span><br><span class="line">go(2) start lock</span><br><span class="line">go(2) locked</span><br><span class="line">go(0) start lock</span><br><span class="line">go(0) locked</span><br><span class="line">go(0) unlock</span><br><span class="line">go(1) unlock</span><br><span class="line">go(2) unlock</span><br></pre></td></tr></table></figure>

<p>可以看到读锁定却并不会阻塞<code>goroutine</code>。</p>
<p><strong>总结：</strong></p>
<ul>
<li>读锁定和写锁定对于写操作都是互斥的</li>
<li>读锁定支持多级嵌套，但写锁定无法嵌套执行</li>
<li>如果有写锁定，当多个读解锁全部执行完成后，则会唤起执行写锁定</li>
<li>写锁定会阻塞<code>goroutine</code>（在Lock()时和互斥锁一样，RLock()时先也是等到RUnlock()先执行，才有锁定机会）</li>
</ul>

        
    </section>
</article>




<nav class="page-nav">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
</nav>



            </div>
        </div>
        <footer class="footer">
    Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>, Theme by <a href="https://github.com/sanonz/hexo-theme-concise" target="_blank">Concise</a>

    
    <script>
        var _hmt = _hmt || [];
        (function () {
            var hm = document.createElement("script");
            hm.src = "https://hm.baidu.com/hm.js?2c09de12c175e88fd5cb35771db9e691";
            var s = document.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(hm, s);
        })();
    </script>
    
</footer>

    </main>

    <script type="text/javascript" src="https://cdn.bootcss.com/jquery/1.9.0/jquery.min.js"></script>
    <script type="text/javascript">
    $(function() {
        var nodes = {
            nav: $('#nav'),
            aside: $('#aside'),
            asideInner: $('#aside-inner'),
            navInner: $('#nav-inner')
        };

        var doing = false;
        nodes.asideInner.on('webkitAnimationEnd mozAnimationEnd oAnimationEnd oanimationend animationend', function() {
            if (nodes.aside.hasClass('mobile-open')) {
                nodes.aside.removeClass('mobile-open');
            } else {
                nodes.aside.removeClass('mobile-close panel-show');
            }
            doing = false;
        });
        $('#open-panel, #aside-mask').on('click', function() {
            if (doing) {
                return;
            }

            if (nodes.aside.hasClass('panel-show')) {
                nodes.aside.addClass('mobile-close');
            } else {
                nodes.aside.addClass('mobile-open panel-show');
            }
        });
        $('#open-menus').on('click', function() {
            nodes.navInner.slideToggle();
        });

        if (window.innerWidth <= 960) {
            setTimeout(function() {
                nodes.navInner.slideUp();
            }, 3000);
        }
    });
    </script>
    

</body>
</html>
